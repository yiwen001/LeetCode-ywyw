# 前端


209. 长度最小的子数组	4
93. 复原IP地址	2
215. 数组中的第K个最大元素	2
226. 翻转二叉树	2
94. 二叉树的中序遍历	2
322. 零钱兑换	1
129. 求根到叶子节点数字之和	1
88. 合并两个有序数组  1

121.买卖股票	1
124. 二叉树中的最大路径和	1
104. 二叉树的最大深度	1

标号为Leetcode的题号，持续更新，写一道更新一道，更新内容为源代码和做题感想，水平较低。本人（因为懒）比较习惯用python写

**209. 双指针+滑动窗口**

input: s，nums. 

a.套路判断list是否为空
```
if not nums:
   return 0
```
b.初始化一些瓶子
```
   plus=0
   left=0
   right=0#初始化右指针
   min-length=float('inf')#最小长初始化为无穷大，因为写的这个函数是针对于所有未知长度的list的
```
c.开始滑动窗口
```
   for left in range(len(nums)): #左指针移动
       while(right<len(nums) and plus<s)：
             plus+=nums[left]
             right=right+1
       if(plus>=s):
          min_length=min(min_length, right-left)
          plus=plus-nums[left]
    
 ```
 d. 判断是否存在满足条件的子数组：
 ```
    if min_length==float('inf'):#没有找到min_length
       return 0
 ```
    return min_length
    
**93.复原IP地址: 三层循环，暴力求解**

[原题链接](https://leetcode-cn.com/problems/restore-ip-addresses/submissions/)
   
a. 因为要用“.”将数字串分为四个部分，所以用三层循环，用i,j,k三个指针来划分
```
 for i in range(3):#每个数不能大于255
    for j in range(i+1, i+4):
       for k in range(j+1,j+4):
           tmp1=s[:i+1]
           tmp2=s[i+1:j+1]
           tmp3=s[j+1:k+1]
           tmp4=s[k+1:]
```
b.IP地址有效->要满足2个条件：1.开头数字不能是0,如果是0的话，数字长度不能大于1（eg:可以0.0.0.0,不能01.0.0.0）  2.不能大于255
  所以为了判断分出来的tmp1,tmp2,tmp3,tmp4是否满足条件我们需要创建一个 judge 函数：
```
   def judge(tmp):
      if not tmp or (tmp[0]=="0" and len[tmp]<1) or int(tmp)>255:
          return False
      return true
    
```
c.然后使用map()函数,统一对tmp1,2,3,4进行判断：
 ``` 
  result=[]
  if all(map(judge，[tmp1, tmp2, tmp3, tmp4])):#[map 算法](https://www.runoob.com/python/python-func-map.html)
       result.append(tmp1+"."+tmp2+"."+tmp3+"."+tmp4)
      
   return result
``` 

    
