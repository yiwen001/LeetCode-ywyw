# 前端


209. 长度最小的子数组	4
93. 复原IP地址	2
215. 数组中的第K个最大元素	2
226. 翻转二叉树	2
94. 二叉树的中序遍历	2
322. 零钱兑换	1
129. 求根到叶子节点数字之和	1
88. 合并两个有序数组  1

121.买卖股票	1
124. 二叉树中的最大路径和	1
104. 二叉树的最大深度	1

标号为Leetcode的题号，持续更新，（抄）写一道更新一道，更新内容为源代码和做题感想，水平较低。本人（因为懒）比较习惯用python写

**[209. 双指针+滑动窗口](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)**

input: s，nums. 

a.套路判断list是否为空
```
if not nums:
   return 0
```
b.初始化一些瓶子
```
   plus=0
   left=0
   right=0#初始化右指针
   min-length=float('inf')#最小长初始化为无穷大，因为写的这个函数是针对于所有未知长度的list的
```
c.开始滑动窗口
```
   for left in range(len(nums)): #左指针移动
       while(right<len(nums) and plus<s)：
             plus+=nums[left]
             right=right+1
       if(plus>=s):
          min_length=min(min_length, right-left)
          plus=plus-nums[left]
    
 ```
 d. 判断是否存在满足条件的子数组：
 ```
    if min_length==float('inf'):#没有找到min_length
       return 0
 ```
    return min_length
    
**[93.复原IP地址: 三层循环，暴力求解](https://leetcode-cn.com/problems/restore-ip-addresses/submissions/)**

a. 因为要用“.”将数字串分为四个部分，所以用三层循环，用i,j,k三个指针来划分
```

 for i in range(3):#每个数不能大于255
    for j in range(i+1, i+4):
       for k in range(j+1,j+4):
          if i < n and j < n and k < n:
           n=len(s)
           tmp1=s[:i+1]
           tmp2=s[i+1:j+1]
           tmp3=s[j+1:k+1]
           tmp4=s[k+1:]
```
b.IP地址有效->要满足2个条件：1.开头数字不能是0,如果是0的话，数字长度不能大于1（eg:可以0.0.0.0,不能01.0.0.0）  2.不能大于255
  所以为了判断分出来的tmp1,tmp2,tmp3,tmp4是否满足条件我们需要创建一个 judge 函数：
```
   def judge(tmp):
      if not tmp or (tmp[0]=="0" and len[tmp]<1) or int(tmp)>255:
          return False
      return true
    
```
c.然后使用map()函数,统一对tmp1,2,3,4进行判断：
 ``` 
  result=[]
  if all(map(judge，[tmp1, tmp2, tmp3, tmp4])):
       result.append(tmp1+"."+tmp2+"."+tmp3+"."+tmp4)
      
   return result
``` 

[map 算法](https://www.runoob.com/python/python-func-map.html) 

***一些碎碎念：***
我觉得做题要有一个框架在脑袋，不管是什么题目，要搞清楚先做什么后做什么，知道要做什么后再想可以用什么思想和方法。
比如这道题，就是对数字串进行分组，要分成4组，分成四组用什么方法呢：用三个指针，for 循环间隔开+if 判断指针有没有越界+judge()函数判断是否满足ip地址的条件
最后用用list[].append(+"."+"."+".")添加到结果list中
所以这道题就分为三步：
1.分组（三个指针for循环）傻逼的我连这个都不知道emmm
2.判断是否满足ip地址条件
3.list.append()

over

**[215.数组中第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)**

1.排序
2.找到第k大的数

为数不多自己写出来的（暴力）解法，此处给自己点掌声
```
class Solution(object):
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        nums.sort(reverse=True)
        #nums=nums[::-1]
        big=nums[0]
        flag=0
        for i in range (len(nums)):
            if nums[i]<=big:
                flag=flag+1
            if flag==k:
                return nums[i]
       
```

